# 컴퓨터구조론

### chapter 01. 컴퓨터 시스템 개요

---

<컴퓨터 시스템>

- 소프트웨어: 정보처리의 종류와 그 수행시간을 지정해주는 command 들의 집합
- 하드웨어: 중앙처리장치(CPU), 기억장치(주, 보조), 입출력장치, power, fan, ect...

---

> 소프트웨어는 하드웨어에 의존적이다.
>
> 즉, 컴퓨터의 수행속도는 근본적으로는 하드웨어에 달려있고 소프트웨어의 질에 따라 하드웨어의 사용 효율이 더 향상될 수 있다.

#### 1.1 컴퓨터의 기본 구조

컴퓨터는 프로그램 코드를 정해진 순서대로 실행(execute)한다.  그 과정에서 컴퓨터는 필요한 데이터를 read, processing, store 한다.

![컴퓨터의 기본구조](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F230ABC4252C55F002A8837)

```
<컴퓨터의 기본구조>
```


- CPU(Processor): 프로그램 실행 및 데이터 처리 - 중추적인 기능 담당
- 기억장치: 주 기억장치와 보조 기억 장치로 나뉜다.


|   주 기억장치   |  보조기억장치  |
| :--------------: | :------------: |
|   빠른 액세스   |  느린 액세스  |
|   가격이 비쌈   | 가격이 저렴함 |
| 저장능력: 휘발성 | 저장능력: 영구 |

- 입출력장치: 각 장치마다 있는 별도의 제어장치에 의해 동작. 유저와 컴퓨터간의 소통을 위한 도구.

#### 1.2 정보의 표현과 저장 _ 17~20 page.

컴퓨터가 처리하는 정보의 종류: ***Code*** , ***Data***  -> bit의 조합으로 표현

- 고급 언어(high-level language): 사람에게 편한 언어
- 컴파일러(Compiler): 고급 언어를 기계어로 변환해주는 소프트웨어
- 기계어(Mauchine language): 기계(컴퓨터의 하드웨어)가 이해할 수 있는 언어
- 어셈블리 언어(Assembly language): 고급 언어를 기계어로 바꿔주는 중간 언어

> CPU의 종류 마다 내부 구조가 다르기 때문에 서로 다른 종류의 CPU의 기계어는 달라진다. 따라서 고급 언어를 기계어로 바꿔주는 과정의 중간에 해당하는 어셈블리 언어가 이를 해결해준다.

고급-언어 프로그램이 기계어 프로그램으로 번역되는 과정은 다음과 같다.


| 고급 언어 프로그램 | 어셈블리 프로그램                                     | 기계어 프로그램                |
| :----------------- | ----------------------------------------------------- | ------------------------------ |
| [예] Z = X + Y     | LOAD A, X: 기억장치 X번지 값을 레지스터A에 적재       | 001 / 00101                    |
| -                  | ADD   A, Y: 기억장치 Y번지 값을 A 와 더한 후 A에 적재 | 100 / 00110                    |
| -                  | STOR  Z, A: A의 내용을 기억장치 Z번지에 저장          | 010 / 00111                    |
| -                  | ***LOAD, ADD, STOR*** 을 ***니모닉스*** 라고 부른다.  | ***opcode 명령/operand 주소*** |

- 기계어 프로그램에서 oprand는 0번지부터 저장되어있고 계산에 사용될 데이터는 X번지 부터 저장
- CPU에서 한번에 처리될 수 있는 비트들의 그룹을 **WORD** 라고 한다

#### 1.3 시스템의 구성 

---

CPU와 기억장치 및 I/O 장치의 상호작용을 분석해보고 컴퓨터시스템의 구성방법 및 동작원리에 대해 알아본다.

---

**1.3.1 CPU와 기억장치의 접속**

![컴퓨터의 기본구조](https://t1.daumcdn.net/cfile/tistory/256A834E52C564C526)

```
<CPU와 시스템 버스>
```


- 시스템 버스: CPU와 시스템 내의 다른 요소들 사이에 정보를 교환하는 통로
  - 주소 버스: CPU가 외부로 발생하는 주소 정보를 전송하는 신호들의 집합
  - 데이터 버스: CPU가 기억장치 혹은 I/O장치 사이에 데이터를 전송하기 위한 신호 선들의 집합
  - 제어 버스: CPU가 시스템 내의 각종 요소들의 동작 제어에 필요한 신호 선들의 집합

> 주소는 CPU에 의해 발생되어 기억장치 및 I/O 장치로 보내지는 정보이기 때문에 주소 버스는 단방향성이다.
>
> 데이터 버스는 읽기 및 쓰기를 지원하므로 양방향성이다. (제어 버스도 마찬가지)

- 액세스: CPU가 기억장치에 데이터를 쓰거나, 저장된 내용을 읽는 동작

![CPU와 기억장치의 접속](img/CPU%EC%99%80%20%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%9D%98%20%EC%A0%91%EC%86%8D.JPG)

```
<CPU와 기억장치의 접속>
```


- Read할 경우 CPU가 보내줘야 하는 정보: 주소, 읽기신호
- Write할 경우 CPU가 보내줘야 하는 정보: 주소, 쓰기신호, 데이터(무엇을 쓸지에 대한)

따라서 CPU와 기억장치 사이에는 주소 버스, 데이터 버스, 제어(쓰기, 읽기 신호 제어) 버스가 필요하다.

![기억장치 액세스 동작의 시간 흐름도](http://mblogthumb4.phinf.naver.net/20121122_51/dufvndrnjs_1353591900999jMzC7_JPEG/%B1%E2%BE%EF%C0%E5%C4%A1_%BE%D7%BC%BC%BD%BA_%B5%BF%C0%DB%C0%C7_%BD%C3%B0%A3_%C8%E5%B8%A7%B5%B5.JPG?type=w2)

```
<기억장치 액세스 동작의 시간 흐름도>
```


- 쓰기 동작의 경우 CPU가 주소, 데이터를 보내는 동시에 쓰기 신호를 활성화 한다. CPU가 주소와 데이터를 보낸 순간부터 기억장치에 저장이 완료될 때 까지의 시간을 **기억장치 쓰기시간**이라고 한다.
- 읽기 동작의 경우 CPU가 주소를 보내는 동시에 읽기 신호를 활성화한다. 일정 **지연 시간**이 흐른 후 읽힌 데이터가 데이터 버스에 실리게 되며 CPU는 그 데이터를 버스 인터페이스 회로를 통하여 읽어들인다.  CPU가 주소를 발생한 시간부터 읽기 동작이 완료될 때까지의 시간을 **기억장치 읽기 시간**이라고 한다.
- **지연 시간**: 주소를 해독(decode)하는 시간 + 기억장치로 부터 데이터를 인출하는데 걸리는 시간

**1.3.2 CPU와 I/O장치의 접속**

I/O 장치와 보조저장장치는 CPU가 직접 제어하지 못하고 별도의 제어기(또는 인터페이스 회로)를 통해야 한다.

![기억장치 액세스 동작의 시간 흐름도](img/CPU%EC%99%80%20I_O%20%EC%9E%A5%EC%B9%98%EB%93%A4%20%EA%B0%84%EC%9D%98%20%EC%A0%91%EC%86%8D.JPG)

```
<CPU와 I/O 장치들 간의 접속>
```


CPU가 키보드로부터 데이터를 읽어들이는 과정은 다음과 같다.

- 키보드의 어느 한 키를 누른다 -> 그에 대응되는 데이터가 키보드 제어기의 데이터 레지스터에 저장된다. -> 상태 레지스터의 입력데이터가 준비되었다는 것을 의미하는 비트(예시에서는 In_RDY)가 활성화된다.
- CPU는 In_RDY비트가 활성화되어 있는지를 검사한다.
  - In_RDY가 활성인 경우: 데이터 레지스터의 내용을 CPU로 읽어들인다.
  - In_RDY가 비활성인 경우: In_RDY가 활성화될 때까지 상태 레지스터를 검사하고 이를 반복한다.

CPU가 데이터를 프린트하는 과정은 다음과 같다.

- 데이터를 프린터로 보내기 전에 CPU는 프린터 제어기 내의 상태 레지스터를 읽어 데이터 출력 준비(Out_RDY)비트를 검사한다. -> Out_RDY비트가 활성상태라면 CPU는 데이터를 프린터 제어기의 데이터 레지스터(데이터 버퍼)로 Write 한다.

CPU는 시스템에 접속되어 있는 I/O 장치들을 직접 제어하지는 않지만, 각 장치의 제어기가 수행할 동작을 지정하는 명령(Command)을 보내거나 상태 정보와 데이터를 주고 받을 수 있어야 한다. 따라서 CPU는 각 I/O 장치의 제어기를 구분하고 정보를 주고받을 수 있어야 한다.

- 각 제어기 내부의 상태 레지스터와 데이터 레지스터를 각각 한 WORD 길이의 기억장치로 간주하면 가능하다. 즉, CPU가 제어기 내부 레지스터의 주소를 이용하여 I/O 장치를 제어할 수 있다.

**1.3.3 전체 시스템의 구성**

![](http://cfile208.uf.daum.net/image/1220551F4B1D2EB905DBF0)

```
<컴퓨터시스템의 전체 구성도>
```


- 프로그램 실행: CPU가 주기억장치로부터 프로그램 코드를 읽어서 실행한다.
- 데이터 저장: 프로그램 실행 결과로서 얻어진 데이터를 주기억장치에 저장한다.
- 데이터 이동: 디스크나 CD-ROM에 저장되어 있는 프로그램과 데이터 블록을 주기억장치로 이동한다.
- 데이터 입력 및 출력: 사용자가 키보드를 통하여 보내는 명령이나 데이터를 읽어 들인다. 또한 CPU가 처리한결과 값이나 기억장치의 내용을 프린터(혹은 모니터)로 출력한다.
- 제어: 프로그램이 순서대로 실행되도록 혹은 필요에 따라 실행 순서를 변경하도록 조정하며, 각종 제어 신호들을 발생한다.

#### 1.4 컴퓨터 구조의 발전 과정

---

초기의 컴퓨터들은 relay와 같은 기계식 부품들로 이루어 만들어졌다. 시간이 흘러 주요 부품들이 TR, IC 칩으로 대체되어 성능이 좋아지고 있다. CPU의 수를 증가시키거나 하나의 칩에 여러 CPU 코어를 포함시키기도 하며 많은 개선이 이루어지고 있다. 그럼에도 컴퓨터의 근본적인 설계 개념은 크게 바뀌지 않고있다.

컴퓨터의 근본적인 설계 개념은 누구에 의해 제안되었는가? 그 당시에 구현된 초기 컴퓨터의 구조를 분석하고 발전 경위를 살펴본다.

---

**1.4.1 초기 컴퓨터들의 구조**

- 1642 Biaise Pascal: 덧셈, 뺄셈
- 1671 Leibniz: 산술연산
- 18xx Charles Babbage: Difference Engine(덧셈, 뺄셈 및 프린트 기능)

  ```
  : Analytical Engine(산술연산 및 프린트 기능)
  ```


  ```
  -> Mill(연산), Store(기억), 카드판독기(입력), 프린터와 카드천공기(출력)
  ```
- 19xx von Neumann: ENIAC(진공관을 이용한 전자식 컴퓨터)

  - 단점: 프로그램을 저장하고 변경하는 것이 불가능
  - 위의 단점을 해결하기 위한 설계 개념: Stored-program
    - 2진수 체계
    - 프로그램과 데이터를 내부에 저장
- 1952 von neumann: IAS 컴퓨터(위의 설계개념을 적용한 디지털 컴퓨터)

  - 프로그램 제어 유닛: 주기억장치로부터 명령어들을 한 개씩 가져와서 실행(IAS 작동)함.
  - 산술논리연산장치(ALU)
  - 주기억장치: 명령어와 데이터 모두 저장
  - 입출력장치
  - 특이사항: 한번에 두 개의 명령어가 인출된다. 하나의 명령어는 프로그램 제어 유닛으로 바로 들어가고 나머지 하나는 명령어 버퍼에 저장되어 있다가 다음 명령어 실행 사이클에 실핸된다. 이로 인해 기억장치 액세스 시간이 단축된다.


<IAS 컴퓨터의 구조>

이와 같이 폰노이만의 설계 개념을 따르는 컴퓨터들은 프로그램이 기억장치에 저장된 순서대로 실행된다. 그 기억장치의 주소는 PC(program counter)에 의해 지정된다.

***폰노이만 아키텍쳐***: 기억장치에 저장된 프로그램을 PC가 지정하는 순서대로 실행시킴. 데이터 메모리와 프로그램 메모리가 구분되어있지 않고 하나의 버스를 갖는 구조를 폰노이만 아키텍쳐라고 부른다.

**1.4.2 주요 컴퓨터 부품들의 발전 경위**

- 진공관 -> TR -> IC칩
- IC칩의 제조과정:
  - Ingot 성장 -> 슬라이스 -> 실리콘웨이퍼 -> 조각내고 회로를 집적 -> IC칩 -> 패키징
  - 집적도에 따라 분류하면 다음과 같다
    - SSI(Small Scale IC): 소규모, 기본적인 디지털 게이트
    - MSI(Medium Scale IC): 수백 개의 TR들이 집적되어있음. counter, decoder, shift register 등.
    - LSI(Large Scale IC): 수천 개의 TR. 8bit 마이크로프로세서 칩 등.
    - VLSI(Very Large Scale IC): 수만~수십만 개의 TR. 마이크로프로세서 칩, 대용량 반도체 기억장치 등.
    - ULSI(Ultra Large Scale IC): 수백만 개 이상의 TR.

높은 집적도의 IC 칩들로 인해 시스템은 다음과 같은 이점을 얻을 수 있다

- 회로들이 더 근접 -> 전기적 통로의 길이(버스 등)가 줄어들어 동작속도 향상
- 컴퓨터의 크기가 감소
- 회로들간의 연결이 칩 내부에서 발생 -> 불량(예를들면 냉납 등)률 감소 -> 부품들의 신뢰성 상승
- 전력 소모 감소, 냉각장치가 간단해짐
- 집적도와 상관없이 칩의 가격은 유지되어 컴퓨터 가격 하락

**1.4.3 컴퓨터시스템의 분류와 발전 동향**

1970년 마이크로프로세서의 출현으로 미니컴퓨터의 시장이 성장했다.

- 개인용 컴퓨터: 마이크로프로세서라는 획기적인 반도체 칩의 출현과 더불어 개발되기 시작한 컴퓨터.

  - 컴퓨터 구조상의 주요 동향은 다음과 같다.

    - 매 3~4년 마다 새로운 마이크로프로세서가 등장함.
    - 칩의 집적도 상승으로 속도와 신뢰성 향상.
    - CPU 내부 구조가 슈퍼스칼라 구조로 발전하며 명령어 실행 속도 향상.
    - 멀티-코어 프로세서의 출현으로 여러 프로그램의 동시 처리 가능.
    - 다양한 입출력이 가능해지면서 멀티미디어 PC로 발전.
    - GUI 제공 소프트웨어 탑재.
    - 고속 I/O 장치를 위한 새로운 버스 규격이 생김.
    - 기억장치의 용량이 크게 증가. 종류도 다양해짐.
  - 데스크탑 컴퓨터, 노트북 컴퓨터, 넷북, 태블릿 PC, 포켓 PC 등 다양한 제품이 출현함.
- 임베디드 컴퓨터: 기계장치, 전자장치의 내부에 포함되어 그 장치들의 동작을 제어하는 컴퓨터들을 뜻한다. 임베디드 컴퓨터는 실시간으로 프로그램을 처리하는 경우가 많은데 이를 위하여 특수 설계된 하드웨어와 소프트웨어를 결합한 형태를 갖게된다. 또한 기억장치 용량을 줄이고 전력을 최소화 하는 등 자원을 최적화시키는 것이 특징 -> 유비쿼터스 컴퓨팅.
- 중형급 컴퓨터시스템: 워크스테이션과 슈퍼미니컴퓨터로 구분된다.

  - 워크스테이션: 64비트 마이크로프로세서를 CPU로 갖으며 고속 그래픽 처리를 위한 하드웨어를 갖고있다. CAD, 동영상처리, 시뮬레이션 등에 사용함. 특징으로는 LINUX, UNIX를 OS로 사용한다.
  - 슈퍼미니컴퓨터: 미니컴퓨터보다 수십배의 성능을 내는 컴퓨터. 다중프로세서 시스템으로 구성되고 있다.일반적으로 하나의 시스템 버스에 다수의 프로세서와 주기억장치, I/O 장치들이 접속되어있다.
  - 대형 컴퓨터시스템을 사용하기 보다 여러 개의 중형급 컴퓨터시스템으로 컴퓨팅 환경을 구축하는 경향으로 가고있다. 이를 다운사이징이라 한다.
- 대형 메인프레임 컴퓨터: 댱ㅅㅇ령 조정정차, 다중 I/O 채널을 이용한 고속 I/O 처리능력을 갖고있다. 정부기관, 은행, 대형 인터넷포털사이트 등에서 데이터베이스 저장 및 관리용으로 사용함.
- 슈퍼컴퓨터: 현존하는 컴퓨터들 중 속도가 현저하게 높은 컴퓨터들을 슈퍼컴퓨터라 한다. 주로 대규모 과학계산 및 시뮬레이션에 사용.

  - 슈퍼컴퓨터는 구조적 특징에 따라 구분가능하다.
    - 파이프라인 슈퍼컴퓨터: CPU 내에 다수의 연산장치가 포함됨.
    - 대규모 병렬컴퓨터: 한 시스템 내에 수천~수만 개 이상의 프로세서를 포함. 하나의 큰 작업을 나누어 병렬처리함. 프로세서들 간의 통신 시간을 최소화할 수 있는 상호연결망 설계가 핵심이다.
    - 클러스터 컴퓨터: 고속 LAN이나 네트웨크 스위치에 의해 서로 연결된 PC들의 집합체를 뜻함. 각각의 PC를 노드라고 부르며 노드들에 포함된 모든 자원들을 통합하여 사용한다. 이를 단일 시스템 이미지라고 한다. 클러스터 컴퓨터는 시스템 신뢰도가 높다.

---

---

---
