## 컴퓨터 시스템의 구조
* 컴퓨터 내부장치: CPU, 메모리
* 컴퓨터 외부장치: CPU, 메모리 외 나머지
* 입력: 컴퓨터 내부로 데이터가 들어오는 것
* 출력: 컴퓨터 외부로 데이터가 나가는것
* 컴퓨터 외부장치 = 입출력 장치

## CPU 연산과 I/O 연산

* 컴퓨터 연산 = CPU가 연산
* 입출력 장치의 I/O의 연산 = 입출력 컨트롤러가 연산
* 로컬버퍼: 각 입출력 장치의 컨트롤러가 입출력된 데이터를 임시로 저장 하는 작은 메모리
  * 디스크나 키보드 등에서 데이터를 읽어오는 경우
    * 컨트롤러가 장치로부터 데이터를 받아 로컬버퍼에 저장함
    * 컨트롤러가 CPU의 서비스가 필요할 때 CPU에게 인터럽트를 신호를 발생시킴(이때 인터럽트 라인이라는 통로를 이용함)
* 프로그램이 디스크의 데이터 요청 -> 디스크 컨트롤러가 로컬버퍼로 데이터 읽어서 가져옴 -> 컨트롤러가 CPU에게 인터럽트를 발생시킴 -> CPU는 인터럽트를 감지하고 관련 업무 수행

## 인터럽트의 일반적 기능

* 운영체제 커널에는 입터럽트가 들어왔을 때 해야 할 일이 미리 다 프로그래밍되어 그 코드가 보관돼 있음
* 인터럽트에는 하드웨어 인터럽트, 소프트웨어 인터럽트가 있음
  * 하드웨어 인터럽트 : 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
  * 소프트웨어 인터럽트 : 소프트웨어가가 인터럽트 라인을 세팅
* 인터럽트 벡터: 인터럽트 종류마다 번호를 정해놓은 자료구조. 여기서 번호는 해야할일이 적힌 코드의 위치를 가리킴
* 인터럽트 처리루틴, 인터럽트 핸들러: 실제 처리할 코드가 정의된 곳
* 보통 인터럽트라하면 하드웨어 인터럽트를 말함. 그래서 소프트웨어 인터럽트를 구분하기 위해 트랩(trap)이라는 용어로 주로 불림
  * 소프트웨어 인터럽트의 예
  * 예외상황(exception)
    * 0으로 나누거나, 자신의 메로리 바깥에 접근하려고 할 때 이에 대한 처리를 위해 발생시키는 인터럽트
  * 시스템 콜(system call)
    * 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 대 운영체제에 서비스를 요청하는 방법
    * 사용자 프로그램이 CPU를 사용하기 싶다고 CPU를 제어하는 코드를 다 짤 수 없어서 인터럽트 라인 세팅을 통해 CPU 제어권을 넘겨 실행하게함
    * 사용자는 이미 존재하는 커널의 코드를 호출해서 처리함
  * 시스템 콜이나 예외상황은 모두 사용자 프로세스로부터 CPU의 제어권이 운영체제에 이양되어 처리되는데, 이 과정에서 프로그램 코드가 직접 인터럽트 라인을 세팅하는 명령을 실행하여 인터럽트를 발생시킨 후 제어권이 넘어가게 되므로 이들도 넓은 의미에서는 인터럽트의 범주에 포함시키는 것

## 인터럽트 핸들링

* 인터럽트 핸들링: 인터럽트가 발생한 경우 처리해야 할 일의 절차
* 인터럽트가 발생되면 일단 현재 상태를 저장
  * 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보(=현재 상태)를 저장
  * CPU는 명령이 실행 될때 레지스터의 데이터를 읽고 쓰면서 작업하는데 인터럽트를 처리하면 이 명령어가 다 사라지기 때문에
    * 레지스터: CPU 내부에 있는 임시 기억장치
* PCB(Process Control Block, 프로세스 제어블록)
  * 현재 시스템 내에서 실행되는 프로그램들을 관리 하기 위해 운영체제내에 있는 자료구조
  * PCB는 각각의 프로그램마다 하나씩 존재하며 해당 플그램의 어느 부분이 실행중이었는지 저장
  * 저장 되는 값들: 프로그램이 실행 중이던 코드의 메모리 주소와 레지스터 값, 하드웨어 상태 등
* 인터럽트가 발생했을때 PCB의 역할
  * 프로그램이 실행된던 중 인터럽트가 발생하면 그 프로그램의 상태는 PC에 저장한후 CPU의 제어권이 인터럽트 처리루틴으로 넘어감
  * 인터럽트 처리가 끝나면 PCB로부터 저장된 상태를 CPU로 복원해 직전 위치부터 실행함
* 오늘날 운영체제는 인터럽트가 발생할 때에만 실행됨
  * CPU가 온전히 사용자 프로그램에 의해서만 사용되다가 인터럽트가 발생해야 운영체제가 CPU를 사용함
  * 사용자 프로그램이 원하는 만큼 CPU를 점유할 수 있게됨

## 입출력 구조

* 입출력: 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것
* 동기식 입출력: 입출력 작업이 완료될때까지 기다렸다가 후속작업을 하는 방식
  * CPU는 동기식 입출력이 끝날때까지 아무작업도 못하고 기다려야돼서 자원의 낭비가 발생함
  * 이때 해당 프로그램에는 CPU를 할당하지 않고 다른 프로그램에 CPU를 할당해서 자원의 낭비를 막는데 할당되지 못하는 상태를 봉쇄 상태(blocked state)라고 함
* 정리
  프로그램 A에서 CPU가 작업중-> 디스크에서 데이터를 불러와야 됨 -> 인터럽트 발생 -> CPU는 프로그램 A에서 손을 떼고 다른 프로그램을 처리하게 됨 -> 프로그램 A에서 필요한 데이터를 다 불러올때까지 프로그램 A는 봉쇄 상태(blocked stated)가 됨
* 비동기식 입출력: 입출력 작업이 완료될때까지 기다리지 않고서도 할수 있는일들을 하는것

## DMA(Direct Memory Access)

* 원칙적으로 메모리는 CPU에 의해서만 접근가능
* CPU는 로컬버퍼와 메모리 사이에 데이터를 옮김
* 입출력장치가 메모리 접근을 원할때마다 CPU에게 인터럽트를 발생시키면 CPU가 할일이 너무 많아짐
* 이를 해결해 주는 장치가 DMA(Direct Memory Access)임
  * DMA는 일종의 컨트롤러
  * DMA가 로컬버퍼에서 메모리로 읽어오는 일을 대행함
  * DMA는 바이트 단위가 아닌 블록단위로 일을 함

## 저장장치의 구조

* 저장장치 = 주기억장치(메모리) + 보조기억장치
* 보조기억장치의 용도
  * 파일 시스템용
    * 전원이 나가도 유지되어야 하는 정보 저장용
  * 스왑 영역용
    * 스왑 영역: 메모리의 연장 공간
    * 메모리는 비싸기 때문에 메모리가 부족한 상황이 흔하게 발생해서 당장 필요하지 않은 부분을 스왑 영역에 내려놓게됨 -> 스왑 아웃이라고함

## 저장장치의 계층 구조

* 위로 갈수록 비싸고 빠름
* 정말 필요한 정보일수록 위로가고 그렇지 않은 부분은 밑에 보관하는 식으로 자원을 효율적이고 빠르게 사용함
* 캐싱 기법: 상대적으로 용량이 적은빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
  * 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장함으로써 두 저장장치 사이의 속도를 완충시킴
  * 예를 들어 프로그램의 코드 중에는 많은 횟수 동안 반복되는 코드와，한번수행되고끝나는부분이 있을수있다. 이러한경우 반복되는 코드를 빠른 저장장치에 올려놓으면 적은 저장공간만으로도 전체 시스템의 평균적인 성능을 향상시킬 수 있다. 이러한 캐싱 기법을 컴퓨터 시스템 내의 다양한 저장장치 계층에서 활용함으로써 적은 용량의 상위 저장장치만으로도 대부분의 경우 빠른 수행 속도의 성능을 얻어낼 수 있게된다.

## 하드웨어의 보안

* 운영체제는 멀티 프로그래밍 환경으로 여러 프로그램을 실행할 수 있다.
* 각 프로그램이 다른 프로그램의 실행을 방해하거나 충돌을 일으킬 수 있다.
* 이를 막기 위해 운영체제는 커널모드(kernel mdoe, system mode)와 사용자모드(user mode)가 있다.
* **커널모드**
  * 중요한 정보에 접근하여 연산하는 경우는 커널모드에서만 실행된다.
  * 모든 종류의 명령을 다 실행할 수 있음
* 하지만 사용자 프로그램이 CPU를 갖고 있는 동안은 운영체제가 이를 감시할 수가 없음(CPU를 차지하고 있지 않기 때문)
* 이 상황을 하드웨어적으로 해결 -> 모드 비트
  * mode bit = 0 -> 커널모드
  * mode bit = 1 -> 사용자모드
* 운영체제에서 사용자 프로그램으로 CPU의 권한을 넘겨줄 때 mode bit를 1로 설정해서 넘겨줌. CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드비트를 조사해 그 값이 0으로 세팅된 경우에만 실행
* 파일 입출력의 경우 사용자가 다른사용자의 파일에 접근하면 안된다. 그래서 커널모드로만 입출력을 할 수 있다.
* 운영체제가 입출력을 실행하기 전에 올바른 입출력인지 판단하고 실행하기 때문에 보안을 유지할 수 있다.

## 메모리 보안

* 여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 다른 프로그램이나 운영체제가 위치한 메모리 영역 침범 가능
* 인터럽트 벡터와 인터럽트 처리루틴이 있는 곳은 각별한 보안 필요

### 기준/한계 레지스터
  * 기준 레지스터(basic register)는 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리상의 가장 작은 주소 보관
  * 한계 레지스터(limit register)는 그 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관

### 메모리 보호

* 메모리 접근 연산이 있을 때마다 하드웨어적으로 현재 접근하려는 위치가 합법적인 범위에 있는지 체크
* 사용자 프로그램은 기준 레지스터의 주소부터 기준 레지스터 + 한계 레지스터값 사이의 주소 영역에만 접근 가능
* 이 범위 밖의 주소에 접근시 예외상황이라는 소프트웨어적 인터럽트 발생
* CPU 제어권을 운영체제로 이양시키고 해당 프로그램 강제 종료

### 페이징(paging)

* 위는 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리 기법을 사용하는 경우에 관한 설명
* 보통은 하나의 프로그램이 메모리의 여러 영역에 나뉘어 위치하는 페이징 기법을 사용

### 특권명령

* 메모리 접근 연산은 특권 명령이 아님
* 하지만 기준 레지스터와 한계 레지스터의 값을 세팅하는 여산은 특권명령으로 규정해야함
* 프로그램이 메모리에 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크해 메모리 보호
* 커널모드에서는 메모리에 무제한으로 접근 가능
